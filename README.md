# DemoNetCoreDesignPattern

## 建立型模式

## 結構型模式

## 行為型模式

## 工廠方法模式 (Factory Method Pattern)

> 定義一個用於建立物品的介面，讓子類決定實體化哪一個類別。工廠方法使一個類別的實例化延遲到其子類別。

## 策略模式 (Strategy Pattern)

> 定義一系列的演算法，並且把這些算法，用介面封裝到有公共介面的策略類中，使他們可以互相替換。

## 單例模式 (Singleton)

> 只有一個實例，而且自行實例化並向整個系統提供這個實例。

## 裝飾模式 (Decorator)

> 動態的給一個類別添加額外的職責。就增加功能來說，裝飾模式相比產生子類別更為靈活。

## 觀察者模式 (Observer Pattern)

> 一種一對多的依賴關係，當物件的狀態改變，所有依賴於它的物件都會得到通知並被自動更新。

## 命令模式 (Command Pattern)

> 將請求傳送者和接收者完全解耦，傳送者與接收者之間沒有直接引用關係，傳送請求的物件只需要知道如何傳送請求，而不必知道如何完成請求。

## 建造者模式 (Builder Pattern)

> 分離一個複雜物品的建造和表示建造的方式。

## 範本方法模式 (Template Method Pattern)

>> 把某些行為或定義推遲到子類別實現，所以可以很簡單的在不改變程式基礎骨架的狀況下，繼承其範本方法，拓展不同的行為方式。

## 轉接器模式 (Adapter Pattern)

>> 用一個介面來轉換另一個已存在的類別。這是經常被使用來用一個已存在的類別，用一個介面來包裝已存在類別使兩個不相容的類別可以共同工作。

## 代理模式 (Proxy Pattern)

>> 為其他物件提供一種代理以控制對這個物件的存取。

## 原形模式 (Prototype Pattern)

>> 從一個物件再建立另外一個可訂製的物件，而且不需要知道任何建立的細節。

## 外觀模式 (Facade Pattern)

>> 為子系統中的一組介面提供一個一致的介面，此模式定義了一個高階介面，這個介面使得這一子系統更加容易使用。

## 狀態模式 (State Pattern)

>> 當一個物件的內在狀態改變時允許改變其行為，這個物件看起來像是改變了其類別。

## 備忘錄模式 (Memoto Pattern)

>> 在不破壞封裝性的前提之下，捕獲一個物件的內部狀態，並在該物件之外保存這個狀態。這樣以後就可將該物件恢復到原先保存的狀態。

## 享元模式 (Flyweight Pattern)

>> 運用共有技術有效的支援大量細粒度的物件。

# 參考資料

## [初探設計模式](https://ithelp.ithome.com.tw/users/20112528/ironman/2113) 
